# Model
gpt-5.2-codex — reasoning_effort=medium

## Why this choice
This is targeted multi-file polish work (path sampling + small cache + setting toggle + one deterministic unit test). Medium effort should be sufficient.

---

## Goal
Implement **V5.5a1: Distance-based pulse speed (more uniform motion)**.

Right now pulses advance by percent (`t += Δt`) and sample `path.pointAtPercent(t)`, which makes pulses appear faster on longer edges and can vary speed along curved paths. Add an **optional** distance-based model that advances by pixels/second along the edge path, while keeping the existing behavior available.

Success criteria:
- Pulses can run in **distance-based** mode: constant speed in pixels/sec along the edge path.
- Keep existing percent-based mode intact (either as default or behind a toggle—prefer minimal UI churn).
- No regressions: pulses still follow the exact `EdgeItem.geometry_path()` and never go mid-air.
- Implementation is cached per-edge and recomputed only when edge geometry changes (avoid per-frame heavy sampling).
- Add a deterministic unit test for the new helper(s) (no Qt scene required).

---

## Touchlist
- CodeSee pulse tick/progress logic (where `t` is advanced)
- Edge geometry/path helper(s) you added in V5.5a (`EdgeItem.geometry_path()` and any cache)
- Add a **per-edge arc-length lookup cache**:
  - sample the path into N points
  - build cumulative distance array
  - support mapping distance->percent (and optionally percent->distance)
- Pulse settings:
  - Prefer a simple toggle in existing pulse settings (if present) OR a constant in the CodeSee config area.
  - Avoid adding brand new screens.
- Unit test module for the helper (place near existing CodeSee tests)
- `docs/codex_prompts/INDEX.md` add an entry for this prompt doc (fill commit hash later)

---

## Forbidden list
- No refactors/renames across CodeSee; keep changes localized
- Don’t touch runtime_bus/core_center/component_runtime unless absolutely needed
- Don’t change Pillars unless the end-of-milestone review says it’s warranted
- No new heavyweight dependencies

---

## Implementation details
1) **Arc-length table builder (pure helper)**
   - Input: a list of points sampled from the path (or a callback that samples points from a QPainterPath).
   - Output:
     - `points: list[(x,y)]`
     - `cumdist: list[float]` starting at 0, monotonic increasing
     - `total_len = cumdist[-1]`
   - Ensure it handles degenerate cases (total_len ~ 0).

2) **Distance->percent mapping**
   - Given `d` in [0, total_len], find the segment via binary search on `cumdist`
   - Interpolate within that segment to estimate a percent `p` in [0,1]
   - Sampling strategy:
     - Use fixed N, e.g. N=64 or 96 (keep modest)
     - Optionally scale N with edge “complexity” if you already have a cheap heuristic, but avoid overengineering.

3) **Integrate into pulse tick**
   - Store pulse progress as either:
     - `edge_dist` (distance traveled) in pixels, OR
     - `edge_percent` plus a flag
   - In distance-based mode:
     - `edge_dist += speed_px_per_sec * dt`
     - wrap at `total_len` (mod) for repeating pulses
     - map to percent then render via `path.pointAtPercent(p)`

4) **Cache / invalidation**
   - Cache arc-length tables keyed by `edge_id` (or edge object identity)
   - Invalidate when `EdgeItem.geometry_path()` changes (use your existing path cache invalidation hook if present)

5) **Unit test (deterministic)**
   - Test the pure mapping helper:
     - cumdist monotonic increasing
     - endpoint mapping: d=0 -> p≈0, d=total -> p≈1
     - mid mapping on a synthetic polyline (e.g., 2 segments) gives expected percent within tolerance

6) **Manual acceptance**
   - In CodeSee view, compare:
     - short edge vs long edge: pulse apparent speed should be similar in distance-based mode
     - curved edge: pulse should move smoothly without noticeable acceleration artifacts
   - Verify multiple pulses on the same edge remain readable (don’t overpack)

---

## Auto-verify (run these)
- `python -m compileall -q app_ui runtime_bus core_center component_runtime ui_system content_system diagnostics tools`
- `python -m pytest -q`

---

## Manual test
1) `python -m app_ui.main`
2) Open CodeSee, trigger pulses on both short and long edges
3) Enable distance-based pulse speed (if you added a toggle) and confirm speed looks uniform.
4) Confirm pulses still follow edge paths exactly (no mid-air).

---

## End-of-milestone Pillars review
Ask: “Did V5.5a1 introduce something that deserves a Pillar check?”
- If no: do nothing.
- If yes: add ONE small deterministic Pillar check + unit test.
