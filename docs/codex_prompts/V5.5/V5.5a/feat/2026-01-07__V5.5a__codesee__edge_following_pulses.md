# Model
gpt-5.2-codex — reasoning_effort=medium

## Why this choice
Multi-file feature work inside CodeSee (edge geometry + animation + rendering + a small test). Medium effort is usually enough; bump to high only if geometry/state is tangled.

---

## Goal
Implement **V5.5a: Edge-following pulses** so pulses travel *on the drawn edge path* (no “mid-air” interpolation), per roadmap acceptance checks.

Outcome requirements:
- Edges expose a single authoritative geometry (QPainterPath or equivalent) used for both:
  - edge drawing
  - pulse sampling (path.pointAtPercent(t))
- Pulse animation state is (edge_id, t) and renders at sampled positions along the edge.
- Works on straight + curved + routed edges.
- Multiple pulses on same edge don’t overlap badly (simple spacing/jitter is fine).

---

## Touchlist
(Discover actual filenames/classes in-repo; these are intent-level targets.)
- CodeSee edge rendering item/class (the place that currently draws edges)
- CodeSee pulse animation manager/tick loop (where pulse positions are computed)
- CodeSee scene/view widget that paints pulses
- Pulse settings (if a speed model toggle already exists, reuse it)
- Add 1 small deterministic unit test for any new pure helper logic (sampling/mapping), not GUI rendering
- `docs/codex_prompts/INDEX.md` (append one entry for this prompt; add commit hash after landing)

---

## Forbidden list
- Don’t change runtime_bus/core_center/component_runtime unless strictly required for CodeSee rendering
- No schema/content repo edits
- No major refactors or renames
- Don’t add new heavy deps
- Don’t touch Pillars unless end-of-milestone review says it’s warranted

---

## Implementation plan
1) **Locate current “mid-air pulses” logic**
   - Find where pulses compute `pos = lerp(src_pos, dst_pos, t)` (or similar).
   - Identify the edge draw routine and its current geometry (line/curve/path).

2) **Make edge geometry authoritative**
   - Ensure each edge exposes a stable `QPainterPath` (or equivalent) that matches exactly what is drawn.
   - Cache the path and invalidate/recompute when endpoints/layout changes.

3) **Render pulses on the path**
   - Change pulse state to reference `edge_id` and `t∈[0,1]`.
   - Compute `pos = edge_path.pointAtPercent(t)` for rendering.
   - If oriented sprites exist, also compute `angle = edge_path.angleAtPercent(t)` (optional for now).

4) **Speed model (keep simple but correct)**
   - Default: constant Δt per tick (percent-space).
   - Optional (only if easy and useful): constant speed by distance:
     - Pre-sample the path into N points
     - Build cumulative distance table
     - Map distance→percent with a small helper (binary search + lerp)
   - Prefer reusing existing pulse settings hooks if present.

5) **Multiple pulses on same edge**
   - Add simple spacing: per-edge pulse index adds a phase offset (e.g., `t + k*0.08` wrap) OR a tiny perpendicular offset if you already have a normal vector.
   - Keep deterministic (no random jitter unless seeded).

6) **Tests**
   - Add a unit test for any new pure helper:
     - e.g., distance→percent mapping monotonicity, endpoints map near 0/1,
       or sampled positions remain within expected bounds.
   - Avoid GUI/QPainter scene instantiation in tests.

7) **Acceptance checks (manual)**
   - In a scene with straight, curved, and routed edges:
     - pulses adhere to edges (visibly on top of the edge path)
     - no mid-air travel
     - multiple pulses share an edge without ugly overlap

8) **Docs bookkeeping**
   - Append to `docs/codex_prompts/INDEX.md`:
     - date, version “V5.5a”, filename, one-line purpose, and later the commit hash.

9) **End-of-milestone Pillars review**
   - Ask: “Did V5.5a introduce something that deserves a Pillar check?”
   - If no: do nothing.
   - If yes: add ONE small deterministic check + unit test (keep it minimal).

---

## Auto-verify (run these)
- `python -m compileall -q app_ui runtime_bus core_center component_runtime ui_system content_system diagnostics tools`
- `pytest -q`
  - If suite is large, at least run the relevant subset covering new test(s).

---

## Manual test (very short)
1) Launch: `python -m app_ui.main`
2) Open CodeSee view; trigger activity that generates pulses.
3) Confirm pulses travel along edges (straight/curved/routed) with no mid-air travel.
4) Verify multiple pulses on one edge remain readable.
