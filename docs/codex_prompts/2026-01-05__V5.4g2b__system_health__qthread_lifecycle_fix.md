# 2026-01-05 — V5.4g2b — Fix Qt abort: “QThread destroyed while still running” (System Health + Pillars runner)

Model: **gpt-5.2 (Codex extension)** — reasoning effort **high**
Justification: native Qt abort on Windows caused by thread lifetime/ownership; needs careful, minimal, correct lifecycle handling.

---

## Goal

Fix the app freeze→quit caused by the Qt fatal condition:

> `QThread: Destroyed while thread ' ' is still running`

This is observed after clicking **System Health → Pillars → Run pillars checks**, and also appears during other UI interactions (e.g., Vector Add inc/dec), which strongly suggests a **background QThread is being prematurely destroyed** and the abort happens on the next event-loop tick / screen action / shutdown.

**Recon anchor:** `system_health.py` Pillars runner clears `self._pillars_thread` too early in `_on_pillars_run_finished`, creating a race where the last strong reference drops while the thread is still running.

---

## Touchlist (allowed edits)

- `app_ui/system_health.py` (primary)
- Optionally: any small shared UI worker helper if it already exists and is used here (keep minimal)
- `tests/pillars/**` (add at least one regression test for the lifecycle helper / wrapper, pure-Python)
- `docs/codex_prompts/INDEX.md` (append entry)

---

## Forbidden list (do NOT change)

- No new dependencies.
- Don’t refactor unrelated screens.
- Don’t replace this with a brand-new job system.
- Don’t change CI workflows in this milestone.

---

## What to change (minimal + correct)

### 1) Stop dropping the last thread reference before it is finished

In the Pillars runner code path (anchors from recon):
- `_run_pillars_checks` (≈ lines 914–972)
- `_on_pillars_run_finished` (≈ lines 974–987)

**Fix pattern:**
- Keep `self._pillars_thread` referenced until `thread.finished` has fired.
- Do NOT set `self._pillars_thread = None` inside `_on_pillars_run_finished` unless you *know* the thread is already finished.
- Instead:
  - connect `thread.finished` to a slot/lambda that clears `self._pillars_thread` (and any worker refs) *after* finish.

### 2) Ensure cleanup order is safe and symmetric

For the Pillars worker/thread wiring:
- `worker.finished` → `thread.quit`
- `worker.finished` → `worker.deleteLater`
- `thread.finished` → `thread.deleteLater`
- Also handle error:
  - `worker.error` → `thread.quit` (and store error for UI)
  - ensure UI slot does not clear thread refs early

### 3) Make screen/widget teardown safe

If the System Health widget/screen can be closed/navigated away while the pillars thread is running:
- implement/extend `closeEvent` (or teardown hook) to:
  - if `self._pillars_thread` exists and `isRunning()`:
    - call `quit()`
    - `wait(<short_timeout_ms>)` (e.g., 1500–3000ms)
    - if still running, log a warning but **do not** drop refs until finished
- Never block the UI for long. Prefer short wait and then let it finish; but ensure we do not destroy the thread object.

### 4) Confirm other QThread users are already safe

Recon notes these existing safe patterns:
- `content_browser.py` install worker (quit/wait in handler)
- `main.py` install worker (quit/wait in handler)
- `system_health.py` general `_run_task` uses teardown `_teardown_task` (≈ 1964+)

Verify these patterns do not clear their last thread refs prematurely either. If they do, apply the same “clear on thread.finished” rule (but keep changes minimal).

---

## Verification (must be done)

### Automated
- `python -m pytest -q tests/pillars`

### Manual (Windows)
Run from terminal:
- `python -m app_ui.main`

Repros:
1) Open **System Health → Pillars** → click **Run pillars checks**
   - App must remain alive
   - No freeze→quit
2) Open **Vector Add lab** → inc/dec values repeatedly
   - App must remain alive
3) Close the app normally
   - No `QThread: Destroyed while thread is still running`

If the message still appears, search console output for the *first time* it appears and identify which thread path is still active (add temporary thread objectName if needed, but keep instrumentation minimal and remove it before final commit unless it’s harmless).

---

## Tests (add at least one regression)

We can’t reliably run Qt GUI tests in CI, but we can still guard against the exact bug class:

Option A (preferred):
- Factor the pillars runner wiring into a small helper function that returns the created `QThread` and installs the “clear on finished” connection.
- Unit test calls the helper and asserts the returned object is stored/returned and not cleared until a simulated “finished” signal path.

Option B:
- Add a pure-Python unit test that imports `system_health.py` and inspects that:
  - `_on_pillars_run_finished` does **not** set `self._pillars_thread = None`
  - thread ref clearing happens in a handler connected to `thread.finished`
(Yes, this is a “structure test”, but it prevents regression without needing Qt runtime.)

---

## Docs workflow (required)

Append to `docs/codex_prompts/INDEX.md`:
- Date: 2026-01-05
- Version: V5.4g2b
- Filename: `docs/codex_prompts/2026-01-05__V5.4g2b__system_health__qthread_lifecycle_fix.md`
- One-line purpose: “Fix Qt abort by holding System Health Pillars QThread refs until thread.finished; safe teardown.”
- After completion: add resulting commit hash + notes.

