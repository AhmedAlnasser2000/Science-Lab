# 2026-01-06 — V5.4j — Pillars: P11 pack metadata + P12 security/capability boundaries

Model: **gpt-5.2 (Codex extension)** — reasoning effort **high**  
Justification: touches install/loader validation + security boundary checks; requires careful containment logic and deterministic tests.

---

## Goal

Implement **V5.4j** from the Pillars roadmap by making two more pillars “real” (non-SKIP):

- **P11 — Plugin/pack dependency metadata**
- **P12 — Security & capability boundaries**

This milestone is **validation-first**: introduce minimal schemas/validation and add pillars checks + unit tests that deterministically PASS/FAIL without GUI.

---

## Touchlist

- `tools/pillars_report.py`
- `tests/pillars/**`
- `schemas/**` *(new small schema(s) if needed)*
- `component_runtime/**` *(if pack discovery/metadata lives here)*
- `core_center/**` *(only if inventory endpoint is the source of truth for “installed packs”)*
- `content_system/**` and/or `ui_system/**` *(only if you reuse existing containment logic; keep minimal)*
- `docs/**` *(short note if needed; avoid long docs)*
- `docs/codex_prompts/INDEX.md` (append entry)

---

## Forbidden list

- No new third-party dependencies.
- No arbitrary code loading for packs (keep current “builtin-only” assumption).
- Do not refactor pack installation/uninstall pipelines unless needed for validation.
- Do not weaken existing path containment checks (must remain strict).
- No network calls.

---

## Milestone definition

### P11 — Pack dependency metadata (REAL CHECK)

**Goal:** Every installed pack must declare machine-readable metadata with:
- `pack_id` (string)
- `pack_type` (e.g., `component_pack` / `ui_pack` / `content_module` as appropriate)
- `version` (string; keep simple semver-ish but don’t enforce full semver rules)
- `requires` / `dependencies` (optional list of `{id, version_range?}` or `{id, min_version?}`)
- Optional: `capabilities` (ties into P12)

**Where metadata lives:**
- Prefer a `pack_manifest.json` inside each pack root in store (or whatever your installer already mirrors).
- If an inventory system already knows pack versions, still require a file-based manifest for determinism.

**Validation:**
- Add a small JSON Schema under `schemas/pack_manifest.schema.json` (or equivalent).
- Provide a validator utility (pure python, no deps) that:
  - parses JSON
  - validates required keys/types
  - performs minimal dependency checks:
    - missing dependency => FAIL
    - self-dependency => FAIL
    - optional: detect simple cycles (A depends on B, B depends on A) => FAIL

**Pillars P11 check (in `tools/pillars_report.py`):**
- Enumerate installed packs via the authoritative inventory mechanism:
  - Prefer Management Core inventory endpoint/module if available in-process;
  - else fall back to scanning store roots for pack manifests.
- For each installed pack:
  - manifest exists and is valid
  - dependencies satisfied by installed set (and version if you support it)
- PASS if all installed packs validate; FAIL otherwise.
- Evidence:
  - list of invalid packs and reasons
  - first few missing deps

---

### P12 — Security & capability boundaries (REAL CHECK)

**Goal:** Enforce that packs/content cannot escape store roots and that “capabilities” exist as a concept.

#### A) Path containment (hard requirement)
Implement/centralize a strict helper like:

- `security/path_guard.py` or `diagnostics/security_guard.py` (location up to you):
  - `resolve_under_root(root: Path, rel: str) -> Path` that:
    - joins root + rel
    - resolves
    - FAILS if resolved path is outside root (path traversal)
    - rejects absolute paths and drive-letter paths on Windows
    - rejects `..` traversal

Re-use existing AssetResolver containment logic if it already exists—just expose a unit-testable function.

#### B) Capabilities concept (minimal)
Define a minimal “capabilities” structure:
- Pack manifest may declare `capabilities: [ "fs.read_store", "ui.render", ... ]` (names up to you)
- Define a small allowlist (or “known capabilities”) in code.
- Default policy: packs only get “safe baseline” capabilities; anything else must be explicitly allowed by policy/config.

**Pillars P12 check (in `tools/pillars_report.py`):**
- Verify path containment helper exists and passes a set of known traversal test vectors.
- Verify capability concept exists:
  - at least one of: schema field + parser + allowlist + enforcement stub
- Verify untrusted path inputs are rejected:
  - `../secret`
  - absolute paths
  - `C:\Windows\...`
- PASS if:
  - containment rejects traversal and absolute paths
  - capability list exists and unknown capabilities are rejected or flagged
- Evidence:
  - list of rejected vectors (expected)
  - capability allowlist length and sample

---

## Tests (required)

Add deterministic unit tests under `tests/pillars/`:

### P11 tests
- PASS: create temp pack store with valid manifests and satisfied deps
- FAIL: missing manifest, invalid JSON, missing dep, self-dep, optional simple cycle

### P12 tests
- PASS: normal relative paths resolve under root
- FAIL: traversal `..`, absolute paths, drive-letter paths, UNC paths if applicable
- Capability: FAIL if unknown capability in manifest (or ensure it’s flagged)

Tests must not require GUI and must not touch the real user filesystem beyond `tmp_path`.

---

## Self-verification (agent must run)

- `python -m pytest -q tests/pillars`
- `python tools/pillars_harness.py --out data/roaming/pillars_reports_v54j`
- Confirm report shows **P11/P12 are PASS or FAIL (not SKIP)**.

---

## Manual verification checklist (for the user)

- `python -m app_ui.main`
- System Health → Pillars → Run pillars checks
  - confirm P11/P12 no longer show SKIP

---

## Docs workflow (required)

Append to `docs/codex_prompts/INDEX.md`:
- Date: 2026-01-06
- Version: V5.4j
- Filename: `docs/codex_prompts/2026-01-06__V5.4j__pillars__p11_pack_metadata_p12_security_boundaries.md`
- One-line purpose: “Make P11/P12 real: pack manifests + dependency validation; strict path containment + capabilities concept; pillars checks + tests.”
- After completion: add commit hash + brief notes.
