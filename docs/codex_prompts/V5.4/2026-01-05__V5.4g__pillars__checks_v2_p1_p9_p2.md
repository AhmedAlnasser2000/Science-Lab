# 2026-01-05 — V5.4g — Pillars checks v2 (P1 + P9 + optional P2)

Model: **gpt-5.2 (Codex extension)** — reasoning effort **medium**
Justification: multi-file but contained changes (new pillars checks + unit tests + small helper docs/manifest). Medium effort should be enough; escalate only if you hit unclear integration points.

---

## Goal

Implement **V5.4g** from the Pillars roadmap:

- Add **2–3 new “real” pillars checks** to the pillars harness:
  - **P1 — Versioning & build identity**
  - **P9 — Config layering & reproducibility**
  - **P2 — Schema versions + migrations** *(optional, but prefer to implement as a real check if it can be done without sweeping refactors)*

- Add **focused unit tests** proving deterministic **PASS** and **FAIL/SKIP** behavior for each new check.

- Keep Pillars UI unchanged unless it breaks (it should “just work”).

---

## Touchlist (allowed edits)

- `tools/pillars_report.py`
- `tests/pillars/**`
- `schemas/**` *(only if needed for P2; prefer adding a small manifest rather than editing every schema)*
- `docs/**` *(only if needed for a migrations placeholder note/doc)*

---

## Forbidden list (do NOT change)

- Do **not** refactor app architecture or UI screens to satisfy checks.
- Do **not** add new heavy dependencies.
- Do **not** change `.github/workflows/*` in this milestone.
- Do **not** make checks nondeterministic (no network, no wall-clock timing gates, no random).

---

## Implementation plan

### 1) P1 — Versioning & build identity (REAL CHECK)

**Intent:** Verify the repo has a **canonical build identity source** and that it returns a non-empty version/build string.

**Preferred approach (deterministic and low-risk):**
- Identify the existing “build identity” module/function (from earlier V5.2 CodeSee work, there should already be something).
- In the pillars harness, implement a check that:
  1) Locates the canonical build identity symbol by import (preferred) or file existence + simple call.
  2) Calls it and verifies it returns a **non-empty** string (or dict with a non-empty field).
  3) Records evidence: module path, callable name, returned value (redact if needed).

**If no canonical identity exists:**
- Add a *minimal* canonical identity function in a sensible place that does not ripple through the app.
  - Example: `diagnostics/build_identity.py` or `app_ui/build_identity.py`
  - Provide `get_build_identity()` returning something stable like:
    - a semver-ish version, plus optional short git hash if available **without running git commands** (avoid nondeterminism).
  - Keep it pure + importable for tests.

**Pillars report behavior:**
- PASS when identity exists and the returned identity string is non-empty.
- FAIL when missing or returns empty/None or raises.
- Evidence must be stable (file path, symbol name, sanitized value).

---

### 2) P9 — Config layering & reproducibility (REAL CHECK)

**Intent:** Verify config sources exist and are layered in expected order:
`defaults → repo config → data/roaming overrides → CLI/env overrides (if supported)`
…and that an “effective config” can be exported/printed.

**Preferred approach:**
- Look for existing config functions (likely `app_ui/config.py` or similar).
- Add a small, testable entry point that returns an **effective config snapshot** and (ideally) its source breakdown.

**Minimum viable contract (OK for this milestone):**
- A function importable by tests and the pillars harness, e.g.:
  - `app_ui.config.get_effective_config_snapshot()` returning:
    ```py
    {
      "effective": {...},         # merged config dict
      "sources": ["defaults", "repo", "roaming", "env"],  # whatever applies
    }
    ```
- If the app already has layering, wrap it. If not, implement a minimal deterministic merge that does not change runtime behavior:
  - Read defaults (in-code dict)
  - Optionally read a repo config file if it exists (e.g., `data/defaults/*.json` or `config/*.json`)
  - Read `data/roaming/*.json` overrides if present
  - Apply env overrides for a small, well-defined set of keys (or detect that env overrides are unsupported and report that as evidence)

**Pillars check:**
- PASS if:
  - the snapshot function exists,
  - returns a dict,
  - returns non-empty `effective`,
  - and `sources` includes at least `defaults` and `roaming` (if roaming exists),
  - and the merged result is stable.
- FAIL if missing/unimportable/empty.
- Evidence: where roaming root is, which files were read, which env keys were applied (names only).

---

### 3) P2 — Schema versions + migrations (OPTIONAL but preferred REAL CHECK)

**Goal for V5.4g:** avoid sweeping schema edits; instead, add a minimal machine-readable manifest and a placeholder migrations note.

**Suggested minimal implementation:**
- Add `schemas/schema_manifest.json` containing:
  - a stable `manifest_version` integer
  - an array of schema entries with:
    - `path` (relative path under `schemas/`)
    - `schema_id` (stable string)
    - `schema_version` (int)
- Add `docs/migrations/README.md` explaining:
  - “No migrations yet; when schema_version increments, we’ll add steps here.”
  - Keep it short.

**Pillars check:**
- PASS if:
  - `schemas/schema_manifest.json` exists and parses,
  - all listed schema files exist,
  - each entry has `schema_id` and integer `schema_version`,
  - migrations README exists.
- SKIP if you decide not to implement P2 in this milestone (but prefer implementing).
- FAIL if the manifest exists but is malformed/inconsistent.

---

## Tests (required)

Add tests in `tests/pillars/` for each new check.

For each check (P1/P9 and P2 if implemented), ensure:
- one test that constructs the minimal expected environment for **PASS**
- one test for **FAIL** (or **SKIP** if you intentionally gate it)

Keep tests deterministic:
- Use temp dirs and monkeypatch environment variables as needed.
- Avoid reliance on git being available.
- Avoid relying on the developer’s local `data/` state; create temp fixtures.

---

## Self-verification (agent must run)

Run:
- `python -m pytest -q tests/pillars`
- If a direct CLI exists for the pillars harness, run it once (non-UI), and confirm the report now shows **at least 4 real checks** (P3, P10, plus P1 and P9; plus P2 if implemented).

If any failures occur, fix and re-run until green.

---

## Manual verification checklist (for the user)

- Open app → **System Health → Pillars**
- Click **Run pillars checks**
- Confirm counts show more PASS/FAIL (fewer SKIP) reflecting P1/P9 (and P2 if implemented)
- Open/copy report path actions still work

---

## Docs workflow (required)

Append a new line to `docs/codex_prompts/INDEX.md`:
- Date: 2026-01-05
- Version: V5.4g
- Filename: `docs/codex_prompts/2026-01-05__V5.4g__pillars__checks_v2_p1_p9_p2.md`
- One-line purpose: “Add real pillars checks for P1/P9 (+ optional P2) with unit tests.”
- After completion: add resulting commit hash + any short notes.
