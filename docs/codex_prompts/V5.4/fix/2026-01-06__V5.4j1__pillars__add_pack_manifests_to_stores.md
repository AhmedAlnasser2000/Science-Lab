# 2026-01-06 — V5.4j1 — Pillars: make P11 PASS by adding pack_manifest.json to installed stores

Model: **gpt-5.2 (Codex extension)** — reasoning effort **medium**  
Justification: mostly data/manifest authoring + small repo-local validation; low risk, but must be careful about store layout and IDs.

---

## Goal

P11 currently FAILs because stores contain installed entries but **no `pack_manifest.json`** exists in those pack roots.

Make **P11 PASS** by adding minimal `pack_manifest.json` files for every installed pack root currently present in:

- `component_store/`
- `content_store/`
- `ui_store/`

No behavioral changes needed beyond adding these manifests (unless you discover the P11 checker is pointed at the wrong roots).

---

## Touchlist

- `component_store/**/pack_manifest.json` *(add as needed)*
- `content_store/**/pack_manifest.json` *(add as needed)*
- `ui_store/**/pack_manifest.json` *(add as needed)*
- `docs/codex_prompts/INDEX.md` (append entry)

*(Only touch code if the checker is clearly scanning the wrong directory names; otherwise leave code unchanged.)*

---

## Forbidden list

- Don’t loosen P11 rules.
- No new dependencies.
- No refactors to pack install/uninstall.
- Don’t add manifests to `data/` runtime outputs; only repo-managed store roots.

---

## Instructions

### 1) Determine “installed pack roots” in the repo
For each of the three store roots (`component_store`, `content_store`, `ui_store`):

- Identify pack root directories (usually direct children).
- A pack root is any directory that represents a pack/module (not a cache/temp folder).
- If there are nested pack roots (e.g., `ui_store/ui_v1/packs/<pack_id>`), follow the existing store structure and place `pack_manifest.json` in the **pack root** that the P11 checker expects.

If unsure, inspect the P11 enumeration logic in `tools/pillars_report.py` and match its assumptions.

### 2) Add minimal manifests
Create `pack_manifest.json` in each installed pack root with this minimal structure:

```json
{
  "pack_id": "<stable id>",
  "pack_type": "<component_pack|content_module|ui_pack>",
  "version": "0.0.0",
  "dependencies": [],
  "capabilities": []
}
```

Rules:
- `pack_id` should match folder name / existing id where possible.
- `pack_type`:
  - content module under `content_store/` → `content_module`
  - ui pack under `ui_store/` → `ui_pack`
  - component pack under `component_store/` → `component_pack`
- Keep `version` simple. If a version already exists somewhere (manifest/README), use it; otherwise `0.0.0` is acceptable.
- Leave `dependencies` empty unless you already have a known dependency.

### 3) Do NOT create competing schemas
A schema for pack manifests already exists from V5.4j (`schemas/pack_manifest.schema.json`). Do not create a second competing schema.

### 4) Append prompt index entry
Append a V5.4j1 entry to `docs/codex_prompts/INDEX.md` referencing this prompt file and noting “added missing pack manifests so P11 passes”.

---

## Self-verification (agent must run)

1) Unit tests:
- `python -m pytest -q tests/pillars`

2) Generate a report:
- `python tools/pillars_harness.py --out data/roaming/pillars_reports_v54j1`

3) Confirm:
- P11 is **PASS** (not FAIL/SKIP)
- No new FAILs were introduced

---

## Manual verification (user)

- Run app: `python -m app_ui.main`
- System Health → Pillars → Run pillars checks
- Confirm P11 PASS + counts updated.

---

## Completion note

If P11 still FAILs after adding manifests, include in your completion summary:
- which store root(s) were scanned
- which pack roots got manifests
- the exact FAIL evidence from the report (missing paths) so we can align checker ↔ store layout.

