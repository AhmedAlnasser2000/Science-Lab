# 2026-01-05 — V5.4g1 — Fix “Run pillars checks” freeze/quit

Model: **gpt-5.2 (Codex extension)** — reasoning effort **high**
Justification: debugging a crash/freeze across UI ↔ worker ↔ harness boundaries is multi-file and failure-prone; use high effort to reproduce, trace, and harden.

---

## Goal

Fix the bug where clicking **System Health → Pillars → “Run pillars checks”** causes the app to **freeze and then quit**.

Expected behavior:
- Clicking Run should **not block the UI**.
- The run should complete (or fail) with **no app termination**.
- On failure, show a clear error in UI (and log it), not a crash.
- The Pillars segment should refresh to the new “latest report” on success.

---

## Touchlist (allowed edits)

- Pillars UI handler + worker code (where the Run button is wired)
  - likely under `app_ui/` (System Health / Pillars segment module)
- `tools/pillars_harness.py` *(only if needed to provide a safe in-process API)*
- `tools/pillars_report.py` *(only if needed for error handling or stable call contract)*
- `tests/pillars/**` (add at least one unit test that would have caught the quit)
- `docs/codex_prompts/INDEX.md` (append entry)

---

## Forbidden list (do NOT change)

- Do not introduce new dependencies.
- Do not change unrelated UI screens.
- Do not weaken Pillars determinism (no network; no wall-clock gates).
- Do not change CI workflows in this fix.

---

## Most likely root causes (investigate in this order)

1) **SystemExit / argparse kills the app**
   - If UI imports `tools.pillars_harness` and calls a `main()` that uses `argparse` + `sys.exit(...)`,
     a `SystemExit` may bubble up and terminate the entire process.
   - Symptom: UI “quits” abruptly, not a Python traceback dialog.

2) **Run executes on UI thread**
   - If the button handler runs the harness synchronously, the UI freezes.
   - Symptom: UI unresponsive during run. (But should not quit.)

3) **Unhandled exception in worker thread marshaled incorrectly**
   - If worker exceptions are not caught and you call UI APIs from the wrong thread, Qt can crash.

4) **Subprocess invocation misconfigured**
   - E.g., calling python in a way that launches a new GUI process, or waiting in a blocking way.

---

## Implementation steps

### A) Reproduce with a stack trace / logging
- Ensure running from terminal (`python -m app_ui.main`) prints tracebacks.
- Add a small **run log** capture for the Pillars run:
  - On each run attempt, write to `data/roaming/pillars_run_latest.log`:
    - start timestamp
    - command or function used
    - success/failure
    - exception traceback (if any)
    - stdout/stderr (if subprocess)
- This log is for debugging and should not impact determinism.

### B) Make harness invocation “safe”
Choose ONE of these approaches (prefer #1):

**1) Subprocess run (recommended)**
- Launch pillars harness via `subprocess.Popen` / `subprocess.run` in a worker thread:
  - command: `[sys.executable, "tools/pillars_harness.py", "--out", <out_dir>]`
- Capture stdout/stderr, return code.
- Never call subprocess APIs on the UI thread.

**2) In-process API (only if subprocess is already problematic)**
- Refactor `tools/pillars_harness.py` to expose a pure function:
  - `run_pillars(out_dir: Path) -> PathToReport`
- Keep CLI entrypoint thin:
  - `if __name__ == "__main__": raise SystemExit(cli_main())`
- UI must call `run_pillars()` (NOT `cli_main()`), and must wrap calls with:
  - `except SystemExit as e: ...` (treat as failure, do not re-raise)

### C) UI threading + lifecycle hardening
- Ensure the Run button handler:
  - disables button while running
  - shows “Running…” state
  - starts work on a background worker (QThread/QThreadPool/QRunnable pattern already used elsewhere)
  - marshals completion back to UI thread safely
- On completion:
  - refresh latest report path and reload report JSON
  - re-enable Run button

### D) Error surfacing (no silent quits)
- If run fails:
  - keep the previous report loaded (don’t wipe UI)
  - show an error banner/toast/label with “Run failed; see log at …”
  - include return code or exception message (short)

---

## Tests (required)

Add at least one unit test under `tests/pillars/` that prevents regression.

Recommended minimal tests:

1) **Harness API does not SystemExit**
   - If you implement `run_pillars()`, test calling it does not raise `SystemExit`.

or

2) **UI invocation wrapper catches SystemExit**
   - If you keep using a CLI-style function, test that the wrapper catches SystemExit and returns failure.

Keep tests pure-Python; do not require Qt event loops if avoidable.

---

## Self-verification (agent must run)

1) `python -m pytest -q tests/pillars`
2) Run the app from terminal:
   - `python -m app_ui.main`
   - Navigate: System Health → Pillars → Run pillars checks
   - Confirm:
     - no freeze/quit
     - report refreshes on success
     - on forced failure (e.g., temporarily point out dir to an invalid path), UI shows error and stays alive
3) Inspect `data/roaming/pillars_run_latest.log` is created and useful.

---

## Manual verification checklist (for the user)

- Launch app
- System Health → Pillars
- Click “Run pillars checks”
- Confirm:
  - app remains responsive (no freeze)
  - app does not quit
  - last updated timestamp and latest report path update
  - Open/copy report still works

---

## Docs workflow (required)

Append to `docs/codex_prompts/INDEX.md`:
- Date: 2026-01-05
- Version: V5.4g1
- Filename: `docs/codex_prompts/2026-01-05__V5.4g1__pillars__ui_run_freeze_quit_fix.md`
- One-line purpose: “Fix Pillars UI run action freeze/quit; harden harness invocation and error handling.”
- After completion: add resulting commit hash + any notes.
