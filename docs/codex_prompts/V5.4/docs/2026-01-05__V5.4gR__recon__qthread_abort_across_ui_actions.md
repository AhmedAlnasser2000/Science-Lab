# 2026-01-05 — V5.4gR — Recon: QThread “Destroyed while thread is still running” abort (Pillars + Vector Lab + others)

Model: **gpt-5.2 (Codex extension)** — reasoning effort **high**
Justification: cross-cutting Qt crash likely due to thread lifetime/ownership across multiple UI actions. Needs careful repo-wide tracing + reproduction.

---

## Goal (RECON ONLY — NO CODE EDITS)

Investigate and pinpoint the root cause of the app freezing then quitting with:

> `QThread: Destroyed while thread ' ' is still running`

This happens in **Pillars Run** and also **Vector lab inc/dec actions** (and possibly others). We need a clear report of:
- the exact code path(s) that spawn the problematic thread
- why the thread object is being destroyed while still running (GC? parent widget destroyed? thread not stopped?)
- minimal, targeted fix options (but do not implement)

---

## Touchlist

- You may open/read any files.
- You may run the app and CLI tools locally.
- You may NOT edit files, commit, or modify the repo state.

---

## Hypotheses to test (ranked)

1) **Local QThread variable / lost reference**
   - A handler creates a QThread in a local scope, starts it, and returns.
   - The QThread is GC’d/destroyed while still running → Qt abort.

2) **Thread parented to a widget that gets destroyed**
   - QThread parent is a screen/widget that is destroyed on navigation or refresh.
   - Thread still running when parent dies → abort.

3) **Worker uses Qt objects from wrong thread**
   - Cross-thread UI access triggers instability; thread cleanup never completes.

4) **Thread cleanup missing quit/wait**
   - Worker finishes but thread not properly stopped; object destroyed prematurely.

---

## Reproduction protocol (collect high-quality evidence)

### A) Terminal run (capture console output)
Run from PowerShell:

```powershell
$env:PYTHONFAULTHANDLER="1"
$env:PYTHONUNBUFFERED="1"
# Optional: increases Qt logging signal (not fatal)
$env:QT_LOGGING_RULES="qt.core.thread=true;qt.qpa.*=false"
python -m app_ui.main
```

Collect full console output for each repro below.

### B) Repro cases to test
1) **Baseline start + clean exit**
   - Launch app → do nothing → close app.
   - Does the QThread warning appear on exit?

2) **Vector Lab inc/dec**
   - Open Vector Add lab → click inc/dec controls until freeze/quit.
   - Capture the exact last action before quit.

3) **Pillars Run**
   - System Health → Pillars → Run pillars checks.
   - Capture last UI state before quit.

If the quit happens too fast, repeat with minimal actions and note the earliest trigger.

### C) Windows crash signature (Event Viewer)
If the app quits without a Python traceback, check:
- Event Viewer → Windows Logs → Application
- Find the Error at the crash timestamp for `python.exe`
Capture:
- Faulting module name
- Exception code (e.g., 0xc0000409 / 0xc0000005)
- Fault offset

(Include this in the recon report.)

---

## Repo-wide trace (static analysis)

### 1) Inventory all QThread usage
Use ripgrep:

- `rg -n "QThread\b" -S app_ui core_center runtime_bus tools`
- `rg -n "moveToThread\b|QThreadPool\b|QRunnable\b|QProcess\b" -S app_ui core_center`

Create a short table:
- file:line
- who creates the thread/process
- what it does
- where the reference is stored (local var? self attribute? parented QObject?)
- how it is shut down (quit/wait/deleteLater connections?)

### 2) Identify the Vector lab inc/dec pathway
Trace from Vector Add lab UI controls:
- locate the slot/callback for inc/dec (search for the button text or handler name)
- follow into any “apply settings / recompute / rerender” functions
- see whether it triggers:
  - a background job
  - a bus request
  - a pack/module install job
  - any QThread/QThreadPool usage

### 3) Identify the Pillars Run pathway
Trace from Pillars UI “Run” button handler:
- does it start a thread/process?
- is it using a generic “background worker” helper used elsewhere?
- does it store the worker/thread strongly on `self`?
- are finished/error signals connected to a cleanup routine?

---

## Output: Recon report format (what to send back)

Produce a report with:

1) **Repro summary**
   - Which repro cases trigger the abort (Baseline exit? Vector? Pillars?)
   - Console output snippets (last ~30 lines) around the abort
   - Event Viewer crash signature (if present)

2) **Primary root cause**
   - Identify the exact thread creator(s) responsible
   - Explain why the QThread is destroyed while running (lost ref / parent destroyed / cleanup missing)

3) **Fix options (no code)**
   - Option A: QProcess for external tasks (pillars, jobs)
   - Option B: QThread lifetime hardening pattern (self-owned, quit/wait/deleteLater, closeEvent handling)
   - Option C: Replace background work with QThreadPool/QRunnable with explicit lifetime mgmt
   - Recommend the smallest change that fixes *both* Vector and Pillars (if shared helper is culprit)

4) **Target files/lines**
   - List the 1–3 most important file:line anchors to change later.

---

## Guardrails

- No code edits.
- No “just implement QProcess everywhere” without proof.
- Prefer one shared culprit (background worker helper) if evidence supports it.

---

## Optional: if you need extra signal
If it’s hard to pinpoint, propose (but do NOT apply) a minimal, temporary instrumentation patch:
- add a unique objectName to threads
- log thread start/finish + owning widget lifetime
But only propose after the static inventory.

---

## Completion criteria
Recon is done when we have:
- a confirmed repro path
- a specific thread owner/creator identified
- a clear explanation for premature destruction
- a recommended minimal fix direction (for a follow-up milestone)
