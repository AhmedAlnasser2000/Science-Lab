# 2026-01-06 — V5.4h — Pillars: P5 Crash capture + Safe Viewer, P6 Logging baseline

Model: **gpt-5.2 (Codex extension)** — reasoning effort **high**  
Justification: cross-cutting but still scoped (runtime plumbing + deterministic pillars checks + tests). Needs careful Windows-safe behavior and data-layout compliance.

---

## Goal

Implement **V5.4h** from the Pillars roadmap by making two more pillars “real” (non-SKIP):

- **P5 — Crash capture + Safe Viewer**
- **P6 — Logging & structured events**

Deliverables must be deterministic, Windows-first, and covered by unit tests that do **not** require an actual crash.

---

## Touchlist

- `tools/pillars_report.py`
- `tools/pillars_harness.py` *(only if needed for stable call contract)*
- `tests/pillars/**`
- `app_ui/**` *(only minimal plumbing + a safe viewer entry point)*
- `diagnostics/**` *(if you keep logging/crash helpers here)*
- `docs/**` *(only if a short logging/crash note is needed)*
- `docs/codex_prompts/INDEX.md` (append entry)

---

## Forbidden list

- Do **not** add new third‑party dependencies.
- Do **not** require reproducing a real crash to pass tests.
- Do **not** write logs/dumps inside the repo root (must follow runtime data layout).
- Do **not** change CI workflows in this milestone.
- Avoid major UI refactors; add the smallest safe viewer surface that satisfies P5.

---

## Requirements & design constraints (Windows-first)

- All runtime outputs must go under the app’s data layout:
  - Prefer `data/roaming/**` (or the established workspace/run roots, if that’s the canonical place for logs/dumps in current code).
- Checks must be deterministic and local-only (no network, no timing gates).
- Any background thread/process used must obey the lifecycle rules (no QThread aborts).

---

## Implementation plan

### 1) P5 — Crash capture + Safe Viewer (REAL CHECK)

#### A) Crash capture baseline (minimal but real)
We need a predictable “crash artifacts root” that:
- exists (or is created) on app run or on first use
- is policy-controlled if you already have policy plumbing (preferred)

Implement a minimal crash capture directory policy:
- Determine canonical crash root (choose ONE consistent location):
  - Recommended: `data/roaming/crashes/` (or `data/roaming/dumps/` if that’s already used elsewhere)
- Provide a helper:
  - `diagnostics/crash_capture.py`:
    - `get_crash_dir() -> Path` (creates directory)
    - optional: `write_crash_marker(exc: BaseException, context: dict) -> Path` (for future; NOT required to be used yet)

Notes:
- We do NOT need to force a crash. Just ensure the directory exists and a “capture plumbing” module is present.

#### B) Safe Viewer entry point (minimal UI surface)
We need a “safe viewer” entry point that can list/view crash artifacts without crashing.

Minimal acceptable options:
- Add a **System Health** segment “Crashes” (Explorer-gated is OK) that:
  - shows crash dir path
  - lists last N files
  - open-folder button
  - optionally open selected file
OR
- Add a minimal “Crash Viewer” screen accessible from Diagnostics (if you already have Diagnostics screen)

Must not depend on heavy parsing. Plain file listing is enough.

#### C) Pillars check for P5
In `tools/pillars_report.py`, implement P5 check that verifies:
- crash module exists and imports
- crash dir resolves to a path under allowed data roots and is creatable
- safe viewer entry point exists (importable symbol), e.g.:
  - `app_ui.system_health.CrashesSegment` / `CrashViewerWidget`
  - or `app_ui.diagnostics.CrashViewerScreen`

PASS when all true, FAIL otherwise.

Evidence:
- crash dir path
- viewer symbol path (module + attribute)

---

### 2) P6 — Logging & structured events (REAL CHECK)

#### A) Establish a canonical logging setup entry point
If a logging setup already exists, use it. If not, add minimal baseline:

- `diagnostics/logging_setup.py` (or similar):
  - `configure_logging() -> dict` returning details:
    - log file path
    - format mode (json or kv)
    - handlers enabled
  - Must ensure log destination is under data roots:
    - Recommended: `data/roaming/logs/physicslab.log` (plus optional rolling suffix)

Structured format requirement:
- Either JSON-per-line OR a key=value stable format
- Keep it deterministic; include timestamp but tests should not assert exact timestamp value.

#### B) Ensure it’s actually used (light-touch)
Prefer to call `configure_logging()` early in app startup if that is safe and low-risk.
If startup wiring is too risky in this milestone, it is acceptable to:
- keep the setup callable and testable
- and have the Pillars check validate the setup *and* that it can emit at least one log line into the file when invoked

#### C) Pillars check for P6
Implement a check that:
- imports logging setup module
- calls `configure_logging()` in a temp environment or safe mode
- verifies:
  - log directory exists/created
  - log file path is under allowed data roots (not repo)
  - emitting a test log line results in non-empty file (or captured stream)

PASS when true; FAIL on missing module, bad path, cannot emit.

Evidence:
- log file path
- handler types
- first/last line length (avoid leaking sensitive content)

---

## Tests (required)

Add unit tests under `tests/pillars/` proving PASS and FAIL for P5 and P6.

### P5 tests (no crash required)
- PASS: mock/redirect data root to temp dir; `get_crash_dir()` creates it; viewer symbol import succeeds.
- FAIL: simulate missing viewer symbol or crash module import failure (monkeypatch path/import).

### P6 tests
- PASS: redirect data root to temp dir; call `configure_logging()`; emit a log record; assert file exists and non-empty.
- FAIL: monkeypatch to return a path outside allowed roots; assert pillars check FAIL with clear reason.

Keep tests deterministic:
- Use tmp_path and monkeypatch environment/config hooks.
- Avoid depending on real user filesystem outside temp dirs.

---

## Self-verification (agent must run)

- `python -m pytest -q tests/pillars`
- Run pillars harness once:
  - `python tools/pillars_harness.py --out data/roaming/pillars_reports_v54h`
- Confirm report now shows additional PASS/FAIL for P5 and P6 (not SKIP).

---

## Manual verification checklist (for the user)

- Launch app: `python -m app_ui.main`
- Navigate to the new/updated crash viewer entry point
  - confirm it opens
  - shows the crash dir path
  - open-folder works
- Confirm a log file is produced under data roots and is being appended to.

---

## Docs workflow (required)

Append to `docs/codex_prompts/INDEX.md`:
- Date: 2026-01-06
- Version: V5.4h
- Filename: `docs/codex_prompts/2026-01-06__V5.4h__pillars__p5_crash_capture_p6_logging_baseline.md`
- One-line purpose: “Make P5/P6 real: crash capture dir + safe viewer entry point; structured logging baseline; pillars checks + tests.”
- After completion: add commit hash + brief notes.
